using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System.Linq;
using SplineMesh;
using UnityEngine.Events;

public class EffectRopeController : MonoBehaviour
{
    public Transform performerTransformRoot;

    RoleManager roleManager;

    List<Performer> performerList = new List<Performer>();
    List<bool> ropeStateList = new List<bool>();
    List<EffectRope> ropeList = new List<EffectRope>();
    bool effectEnabled = false;

    void Awake()
    {
        roleManager = FindObjectOfType<RoleManager>();


        for (int i=0; i<performerTransformRoot.childCount; i++)
        {
            performerList.Add(performerTransformRoot.GetChild(i).GetComponent<Performer>());
        }

        for(int i=0; i< transform.childCount; i++)
        {
            ropeStateList.Add(false);
            EffectRope rope = transform.GetChild(i).GetComponent<EffectRope>();
            Vector2Int performer_index = GetPerformerIndexOfRope(i);
            rope.BindPerformer(performerList[performer_index.x], performerList[performer_index.y]);
            ropeList.Add(rope);
        }
    }

    void Start()
    {
        
    }

    void OnEnable()
    {
        roleManager.OnStartPerformingEvent.AddListener(OnStartPerforming);
        roleManager.OnStopPerformingEvent.AddListener(OnStopPerforming);
    }
    void OnDisable()
    {
        roleManager.OnStartPerformingEvent.RemoveListener(OnStartPerforming);
        roleManager.OnStopPerformingEvent.RemoveListener(OnStopPerforming);
    }

    void OnStartPerforming(int index, ulong client_index)
    {
        UpdateAllRopeState();
    }

    void OnStopPerforming(int index, ulong client_index)
    {
        UpdateAllRopeState();
    }

    void UpdateAllRopeState()
    {
        for (int i = 0; i < ropeStateList.Count; i++)
        {
            bool cur_rope_state = GetRopeState(i);
            // Just active rope, generate a new one
            if (cur_rope_state == true && ropeStateList[i] == false)
            {

            }
            // Just deactive rope
            if (cur_rope_state == false && ropeStateList[i] == true)
            {

            }
            ropeStateList[i] = cur_rope_state;

            SetRopeState(i, cur_rope_state);
        }
    }

    bool GetRopeState(int rope_index)
    {
        if (effectEnabled == false)
            return false;

        Vector2Int performer_index = GetPerformerIndexOfRope(rope_index);
        return performerList[performer_index.x].isPerforming.Value == true && performerList[performer_index.y].isPerforming.Value == true;
    }

    Vector2Int GetPerformerIndexOfRope(int rope_index)
    {
        // Rope 0: Performer 0 , 1
        // Rope 1: Performer 0 , 2
        // Rope 2: Performer 1 , 2
        int start_index = rope_index == 2 ? 1 : 0;
        int end_index = rope_index == 0 ? 1 : 2;
        return new Vector2Int(start_index, end_index);
    }

    void SetRopeState(int index, bool state)
    {
        ropeList[index].SetRopeState(state);

        //transform.GetChild(index).gameObject.SetActive(state);
        
        //SetSplineMeshVisible(index, state);
    }

    void SetSplineMeshVisible(int index, bool visible)
    {
        Transform root_transform = transform.GetChild(index).Find("generated by SplineMeshTiling");
        root_transform?.gameObject.SetActive(visible);
    }

    public void SetEffectState(bool state)
    {
        effectEnabled = state;
        UpdateAllRopeState();
    }

    #region OscReceiverFunction
    //void OnReceive_JointMass(float v)
    //{
    //    SetRigidBody("Joints", "mass", v);
    //}
    //void OnReceive_JointDrag(float v)
    //{
    //    SetRigidBody("Joints", "drag", v);
    //}
    //void OnReceive_SegmentMass(float v)
    //{
    //    SetRigidBody("Segments", "mass", v);
    //}
    //void OnReceive_SegmentDrag(float v)
    //{
    //    SetRigidBody("Segments", "drag", v);
    //}
    //void OnReceive_RopeThickness(float v)
    //{
    //    SetRopePathThickness(v);
    //}


    /// <summary>
    /// 
    /// </summary>
    /// <param name="type">Achors / Joints / Segments</param>
    /// <param name="param">Mass / Drag / Angular Drag</param>
    /// <param name="v"></param>
    void SetRigidBody(string type, string param, float v)
    {
        for (int i = 0; i < transform.childCount; i++)
        {
            Transform root = transform.GetChild(i).Find(type);
            Rigidbody[] rigid_list = root.GetComponentsInChildren<Rigidbody>();
            foreach (Rigidbody rigid in rigid_list)
            {
                if (param == "mass") rigid.mass = v;
                else if (param == "drag") rigid.linearDamping = v;
                else if (param == "angular") rigid.angularDamping = v;
            }
        }
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="param">spring / damper</param>
    /// <param name="v"></param>
    void SetJoint(string param, float v)
    {
        for (int i = 0; i < transform.childCount; i++)
        {
            Transform joint_root = transform.GetChild(i).Find("Joints");
            HingeJoint[] hinge_list = joint_root.GetComponentsInChildren<HingeJoint>();
            foreach (HingeJoint hinge in hinge_list)
            {
                JointSpring spring_settings = new JointSpring();
                spring_settings.spring = param == "spring" ? v : hinge.spring.spring;
                spring_settings.damper = param == "damper" ? v : hinge.spring.damper;
                hinge.spring = spring_settings;
            }
        }
    }
    

    void SetRopePathThickness(float v)
    {
        for (int i = 0; i < transform.childCount; i++)
        {
            Transform segment_root = transform.GetChild(i).Find("Segments");
            for(int k= 0; k < segment_root.childCount; k++)
            {
                segment_root.GetChild(k).localScale = new Vector3(v, v * 2f, v);
            }

            Transform joint_root = transform.GetChild(i).Find("Joints");
            for (int k = 0; k < joint_root.childCount; k++)
            {
                joint_root.GetChild(k).localScale = new Vector3(v, v, v);
            }
        }
    }
    #endregion


    int CombinationFormula(int total, int choose)
    {
        if (choose < 1 || total < choose)
            return 0;

        float result = 1;
        for (int i = 0; i < choose; i++)
        {
            result *= (float)(total - i);
        }
        for (int i = 0; i < choose; i++)
        {
            result /= (float)(choose - i);
        }
        return (int)(result);
    }

    #region UI Slider Callback
    public void SetAllDrag_UI(float v)
    {
        SetRigidBody("Joints", "drag", v);
        SetRigidBody("Segments", "drag", v);
    }

    public void SetAllMass_UI(float v)
    {
        SetRigidBody("Joints", "mass", v);
        SetRigidBody("Segments", "mass", v);
    }

    public void SetAllSpring_UI(float v)
    {
        SetJoint("spring", v);
    }

    public void SetAllDamper_UI(float v)
    {
        SetJoint("damper", v);
    }
    public void SetAllAngularDrag_UI(float v)
    {
        SetRigidBody("Joints", "angular", v);
        SetRigidBody("Segments", "angular", v);
    }

    public void SetAllThickness_UI(float v)
    {

    }
    public void SetJointDrag_UI(float v)
    {
        SetRigidBody("Joints", "drag", v);
    }

    public void SetSegmentDrag_UI(float v)
    {
        SetRigidBody("Segments", "drag", v);
    }

    public void SetJointMass_UI(float v)
    {
        SetRigidBody("Joints", "mass", v);
    }

    public void SetSegmentMass_UI(float v)
    {
        SetRigidBody("Segments", "mass", v);
    }
    #endregion

    ////////////////////////////////////////////////////////////
    // Attempt to set connected anchor position automatically to make the rope movement more reasonable.
    // But it failed.
    ////////////////////////////////////////////////////////////
    //void AutoResetConnectedAnchor()
    //{
    //    for (int k = 0; k < ropeStateList.Count; k++)
    //    {
    //        if (ropeStateList[k] == false)
    //            continue;

    //        Transform joint_root = transform.GetChild(k).Find("Joints");
    //        int joint_count = joint_root.childCount + 2;
    //        int segment_count = joint_count - 1;

    //        Transform anchor_root = transform.GetChild(k).Find("Anchors");
    //        Transform start_anchor = anchor_root.GetChild(0);
    //        Transform end_anchor = anchor_root.GetChild(1);

    //        Vector3 start_pos = start_anchor.position;
    //        Vector3 end_pos = end_anchor.position;
    //        Vector3 dis_vec = end_pos - start_pos;
    //        Vector3 dis_unit = dis_vec / segment_count;
    //        Debug.Log("Dis / joint count = " + dis_vec / joint_count);
    //        Debug.Log("Dis / segment count = " + dis_vec / segment_count);


    //        start_anchor.GetComponent<HingeJoint>().connectedAnchor = Vector3.Scale(dis_unit * 0.5f, new Vector3(1.0f / start_anchor.localScale.x, 1.0f / start_anchor.localScale.y, 1.0f / start_anchor.localScale.z));
    //        end_anchor.GetComponent<HingeJoint>().connectedAnchor = -Vector3.Scale(dis_unit * 0.5f, new Vector3(1.0f / end_anchor.localScale.x, 1.0f / end_anchor.localScale.y, 1.0f / end_anchor.localScale.z));
    //        for (int i = 0; i < joint_root.childCount; i++)
    //        {
    //            Transform joint = joint_root.GetChild(i);
    //            HingeJoint[] hinges = joint.GetComponents<HingeJoint>();

    //            HingeJoint hinge = hinges[0];
    //            hinge.autoConfigureConnectedAnchor = false;
    //            hinge.autoConfigureConnectedAnchor = true;
    //            //hinge.connectedAnchor = Vector3.Scale(dis_unit * 0.5f, new Vector3(1.0f/joint.localScale.x, 1.0f / joint.localScale.y, 1.0f / joint.localScale.z));

    //            hinge = hinges[1];
    //            hinge.autoConfigureConnectedAnchor = false;
    //            hinge.autoConfigureConnectedAnchor = true;
    //            //hinge.connectedAnchor = -Vector3.Scale(dis_unit * 0.5f, new Vector3(1.0f / joint.localScale.x, 1.0f / joint.localScale.y, 1.0f / joint.localScale.z));
    //        }
    //    }
    //}
}
